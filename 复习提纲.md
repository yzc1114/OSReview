# 操作系统

### <a href="#概述部分"> 概述 </a>

### <a href="#进程管理部分"> 进程管理 </a>

### <a href="#内存管理部分"> 内存管理 </a>

### <a href="#文件管理部分"> 文件管理 </a>

### <a href="#设备管理部分"> 设备管理 </a>

## 概述部分

### 操作系统特征

并发、共享、虚拟、异步

### 设计目标

方便性、有效性、可扩充性、开放性

### 双重模式

管态，目态

### 操作系统结构

分层方法、微内核、模块

### 中断分类

1. 强迫性中断：正在运行的程序所不期望的，来自硬件故障或外部请求。
   
   1. I/O 中断：来自外部设备通道；
   2. 程序性中断：运行程序本身的中断，如 溢出、缺页中断、缺段中断、地址越界。
   3. 时钟中断
   4. 控制台中断
   5. 硬件故障

2. 自愿性中断：用户在编程时要求操作系统提供的服务，使用访管指令或系统调用使中断发生。也称为访管中断，软中断。
   
   1. 执行I/O
   2. 创建进程 
   3. 分配内存
   4. 信号量操作
   5. 发送/接收消息。

## 进程管理部分

### 进程概念

1. 进程是系统分配的独立单元。
2. 进程由 代码、数据、PCB组成
3. 进程包含： 栈，堆，数据，文本

### 进程状态

1. 新的
2. 运行
3. 等待
4. 就绪
5. 终止

### PCB

1. 进程状态
2. 程序计数器
3. CPU寄存器内容
4. CPU调度信息： 进程优先级、调度队列的指针
5. 内存管理信息： 基址、界限寄存器、页表、段表
6. 记账信息
7. I/O状态信息：打开的文件列表，分配给进程的I/O设备列表。

### 进程调度

#### 调度队列

1. 就绪队列
2. 设备队列：等待设备I/O，每个设备一个

#### 调度程序

1. 长期调度程序（作业调度程序）
   
    从磁盘中的缓冲池中，选择进程，装入内存并执行。

2. 短期调度程序（CPU调度程序）
   
    从准备执行的进程中选择进程，并为之分配CPU。

3. 中期调度程序
   
    将进程从内存中移除，从而降低多道程序设计的程度。称为交换。

### 进程操作

fork，在父程序中返回子程序的pid， 在子程序中返回0

### 进程间通信

1. 消息传递
2. 共享内存

### 线程概念

1. 每个线程有独立的栈和寄存器
2. 优点：
   - 响应度高
   - 资源共享
   - 经济
   - 多处理器体系结构的利用
3. 是CPU调度和分派的基本单位。进程是资源分配的基本单位。

### 多线程模型

- 用户线程：受内核支持，无须内核管理
- 内核线程：操作系统直接支持和管理
1. 多对一
2. 多对多
3. 一对一

### CPU调度

#### 调度准则

1. CPU使用率

2. 吞吐量

3. 周转时间
   
    从进程提交到进程完成的时间段

4. 等待时间
   
    在就绪队列中等待所花费时间之和

5. 响应时间
   
    从提交请求到产生第一响应的时间

#### 调度时机
1. 一个进程 运行->等待
2. 一个进程 运行->就绪
3. 一个进程 等待->就绪
4. 一个进程终止
非抢占只会在1，4时进行调度。

#### 调度算法

1. FCFS
   - 非抢占的
   - 最垃圾
2. SJF
   - 平均等待时间最短
   - 无法实现，因为不知道下一个CPU区间的长度
   - 可以是抢占的，也可以是非抢占的
   1. 非抢占的
   
   2. 抢占的
      
       最短剩余时间调度，可以抢占，挑选剩余运行时间最短的进程。
3. 优先级调度
   - 可以是抢占的，也可以是非抢占的
   - 问题：无穷阻塞、饥饿。 解决方法：老化（提升等待时间久的进程的优先级）
4. 轮转法调度
   - 为分时系统设计
   - 循环队列，使用时间片。
5. 多级队列调度
   - 将就绪队列分成多个独立队列，每个队列有自己的调度算法
   - 每个队列的优先级也不同
6. 多级反馈队列调度
   - 越高级的队列，时间片越短
   - 每个进程在用完时间片后，将会沉入下一级队列
   - 在较低优先级的队列中等待时间过长的进程会被转移到更高优先级的队列中

### 进程同步

#### 临界区

- 访问互斥变量的代码块
- 特征：当一个进程进入临界区，没有其他进程可被允许在临界区执行

#### Peterson算法

- 谦让算法
  
  对于程序Pi:
  
  ```
  do{
    flag[i] = true;
    turn = j;
    while(flag[j] && turn == j);
    临界区
    flag[i] = false;
    剩余区
  }while(true)
  ```

#### 硬件同步

- 特殊硬件指令，能够原子地检查和修改字的内容
1. TestAndSetLock
   
   ```
   do{
    while(TestAndSetLock(&lock));
    临界区
    lock = false;
    剩余区
   }while(true);
   ```

2. Swap
   
   ```
   do{
    key = true;
    while(key == true)
        Swap(&lock, &key);
    临界区
    lock = false;
    剩余区
   }while(true);
   ```

    3. 开中断 关中断

#### 信号量

##### 组成

一个整数变量，一个进程链表

##### 需要注意

1. 信号量的值为负数，那么其绝对值就是等待该信号量进程的个数
2. 原子执行

##### 操作

1. wait ==> P操作
   
   ```
   wait(semaphore *S){
    S->value--;
    if(S->value < 0){
        add this process to S->list;
        block();
    }
   }
   ```
2. signal ==> V操作
   
   ```
   signal(semaphore *S){
    S->value++;
    if(S->value <= 0){
        remove a process from S->list;
        wakeup(P);
    }
   }
   ```

#### 经典同步问题

##### 生产者，消费者

- 需要三个信号量
  - empty(n)
  - full(0)
  - mutex(1)
- 生产者操作步骤：wait(empty), wait(mutex), signal(mutex), signal(full)
- 消费者操作步骤：wait(full), wait(mutex), signal(mutex), signal(empty)

##### 读者，写者

- 需要两个信号量，一个变量readcount
  - wrt(1)
  - mutex(1)
- 写者操作：wait(wrt), signal(wrt)
- 读者操作：较复杂
  1. 对readcount修改需要互斥。先wait(mutex)
  2. 将readcount+1， 若readcount == 1则说明这是第一个读者，需要查看是否有人在写，所以wait(wrt)
  3. 读完之后，将readcount-1，此时若readcount == 0 则说明读者没了，此时将signal(wrt)，让正在等待的写者醒来。

#### 管程

##### 概念

是一种语言构造，monitor类，里面由程序员实现一组操作，保证不会发生死锁，使进程良好的同步

##### 使用

在管程内部，有多个条件变量，可以将自身挂起在其中任何一个条件变量上。
内部为每个条件变量维护一个队列。

### 死锁

#### 必要条件

1. 互斥
2. 占有并等待
3. 非抢占
4. 循环等待

#### 资源分配图

1. 资源指向进程：分配边
2. 进程指向资源：申请边
- 若分配图没有环，则系统没有发生死锁
- 若分配图存在环，则可能会有死锁

#### 处理方法

1. 死锁预防
   - 手段：保证死锁的四个必要条件之一不会发生
   - 缺点：低设备利用率和系统吞吐率
   1. 解决互斥：无
   2. 解决占有并等待：申请前不占用其他资源 或 没有资源时才可申请资源
   3. 解决非抢占：变为可抢占
   4. 解决循环等待：资源按序分配
2. 死锁避免
   - 需要获取每个进程需要的资源种类及其资源数
   - 根据事先信息，构造算法以保证不会死锁
   - 安全状态：系统能按某个顺序为每个进程分配资源
   - 不安全状态：不存在这样的顺序
   1. 资源分配图算法
   2. 银行家算法
3. 死锁检测
4. 死锁恢复
   1. 进程终止
   2. 资源抢占

## 内存管理部分

### 基地址寄存器和界限寄存器

含有能够访问地址最低位，以及能够访问的内存长度。

### 地址绑定

1. 编译时确定
   
    绝对代码

2. 加载时确定
   
    可重定位代码，在加载时才能确定地址的大小

3. 执行时确定
   
    进程在执行时可以从一个内存段移动到另一个，绑定必须延迟到执行时。

### 程序装入技术
1. 绝对装入技术
	程序地址再定位在执行之前被确定，也就是在编译链接时直接制定程序在执行时访问的实际存储器地址。
2. 可重定位装入技术
	- 可执行文件中，列出各个需要重定位的地址单元和相对地址值，装入时再根据所定位的内存地址去修改每个重定位地址项，添加相应偏移量
        1. 静态重定位
        	由装入程序在程序执行之前进行地址再定位，地址定位完成后，在程序执行期间不会发生变化。
        2. 动态重定位
        	程序装入内存时，不修改逻辑地址，在访问物理内存之前，再实时地将逻辑地址转换成物理地址。
        	
### 内存管理单元 MMU

进行逻辑地址与物理地址的转换。

### 动态加载

一个子程序只有在被调用时才会被调入内存

### 动态链接和共享库

将链接延迟到运行时，常用于系统库，语言子程序库，如stdio.h。如果没有这种机制，所有程序都需要一份语言库的副本，浪费空间，。

### 连续内存分配

1. 固定分区
2. 动态分区
   1. 首次适应
   2. 最佳适应：最小的孔
   3. 最差适应：最大的孔
3. 会有外碎片，解决方法：紧缩

### 分页

#### 碎片

只有内碎片

#### TLB

转换表缓冲区，存放最近使用的页表，加快查询页表的速度。

#### 种类

1. 多层页表

2. 哈希页表

3. 反向页表
   
    每个真正的内存帧有一个条目，整个系统只有一张表

### 分段

纯分段策略，程序是全部装入内存的，只不过每段分开存储而已。通过段表查询。

### 虚拟内存

#### 按需调页

#### 页面置换

1. FIFO

2. OPT

3. LRU
   
   1. 计数器
   2. 栈

4. 近似LRU
   
   1. 附加引用位
      - 八位移位寄存器，若00000000则代表最近八个周期没有使用
      - 每个时钟周期向右移位，最左边的数代表最近一个周期是否使用
   2. 二次机会算法
      - 引用位为0，则直接置换，并设置引用位为1
      - 引用位为1，则给他机会。
   3. 增强型二次机会
      - （0，0）最近没有使用没有修改
      - （0，1）最近没有使用但修改
      - （1，0）最近使用没有修改
      - （1，1）最近使用且修改

5. LFU
   
    最不经常使用。使用次数最少的页

6. MFU

#### 帧分配算法

1. 平均分配
2. 比例分配    
   
    按照每个程序需要的内存大小，按比例分配帧

#### 全局分配 局部分配

#### 系统颠簸

- 频繁换入换出。
- 解决：工作集合模型
  - 检查最近△个页的引用，这几个页的集合成为工作集合
  - 为进程分配大于工作集合的帧数，放置颠簸

## 文件管理部分

### 文件概念

记录在外存上的相关信息的具有名称的集合。

### 文件目录结构

1. 单层目录结构
2. 双层目录结构
3. 树状目录结构
4. 无环图目录
   1. 硬链接
      
       使用inode的引用计数
   
   2. 软链接
      
       相当于快捷方式
5. 通用图目录

### 虚拟文件系统 VFS

定义了一个文件系统操作的统一接口，在用户和实际操作系统之间，使得用户可以使用同一种方法，来调用不同的文件系统。

### 目录文件的实现

1. 线性列表
2. 哈希表

### 分配方法

1. 连续分配

2. 链接法
   
    FAT，需要对FAT表缓存在内存中。

3. 索引法
   
    **UFS**
   
   * unix的inode结构：
     * 十个直接块
     * 一个一级间接块
     * 一个二级间接块
     * 一个三级间接块
     * 共13个指针

### 空闲空间管理

1. 位向量法
2. 链表法
3. 成组链接法

### **UNIX FCB分解法**

UNIX中，目录文件只存储inode号以及文件名。在inode区存储真正的inode（除去文件名）。这种方法减少了查找文件inode的访盘次数。

## 磁盘管理部分

### 访盘时间

一次访盘时间 = 寻道时间 + 旋转延迟时间 + 存取时间

- 寻道时间：磁头移动
- 延迟时间：磁盘转动
- 存取时间：数据传送

### 调度方法

- 先来先服务（FCFS）
- 最短寻道时间优先（SSTF）
- 扫描算法（电梯算法）
- 单向扫描算法

### RAID

磁盘容错技术，通过增加冗余的磁盘驱动器、磁盘控制器等来提高磁盘系统的可靠性。

## 设备管理部分

### 设备分类

1. 从资源分配角度
   1. 独占设备
      
       同时只能有一个进程使用的设备
   
   2. 共享设备
      
       同时可以有多个进程使用的设备
   
   3. 虚拟设备
      
       SPOOLing技术，假脱机技术。使用硬盘模拟输入输出设备。将独占设备虚拟成共享设备。
2. 从程序使用角度
   1. 逻辑设备
   2. 物理设备

### 设备无关性

应用程序引用的、用于实现I/O操作的设备（逻辑名）与物理I/O系统中实际安装的设备没有固定的联系。

### 设备映射

操作系统的设备管理程序将逻辑设备转换成对相关物理设备的引用。

### 设备驱动

对物理设备进行控制，以实现真正的I/O操作。

### 系统分层

1. 用户进程
2. 设备无关程序
3. 设备驱动程序
4. 中断处理程序
5. 硬件

### 端口编址方法

1. 内存映像编址（内存映像I/O模式）
   
    优点：
   
   1. 可对存储器操作的指令都可以对端口操作
   
   2. 不需要专门的I/O指令
   
   3. I/O端口可有较大地址空间
      
      缺点：
   
   4. 占用内存空间

2. I/O独立编址（I/O专用指令）
   
    优点：
   
   1. 不占用内存地址空间
   
   2. 程序设计时，易于区分是对内存操作还是对I/O端口操作
      
      缺点：
   
   3. I/O端口操作的指令类型少，操作不灵活

### 缓冲区

- 引入目的：缓解CPU与外部设备之间速度不匹配的矛盾，提高资源利用率
1. 硬缓冲：在设备中设置缓冲区，由硬件实现
2. 软缓冲：在内存中开辟一个空间，用做缓冲区

### 虚拟设备

- 在独占型设备与进程之间加入一个共享型设备作为过渡
- 多个设备可以同时使用一个独占型设备，其实是每一个进程对应一个虚拟设备
- **SPOOLing**核心思想：在快速辅助存储器中建立I/O缓冲区。
